<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1">
  <POU Name="MeasurementRecorder" Id="{93dbaa42-5e8f-4c04-9f41-cddca8209cc2}" SpecialFunc="None">
    <Declaration><![CDATA[(*
## Short summary


This is class that can be used to generate process related measurements and store them to a Database.
Measurements are going to be queued in a linked list and send to the database one after another. 

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2025 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

*)

FUNCTION_BLOCK MeasurementRecorder EXTENDS CNM_OpModeHandler.AbstractCyclicNode 
	IMPLEMENTS 	CNM_ProductionMetricInterfaces.IMeasurementRecorder
VAR
	(* queue for the measurements *)
	dataSetList :CNM_Collections.LinkedList;
	(* the variable that is used to provide data for the database *)
	{ attribute 'TcHmiSymbol.ShowRecursively' }
	measurement :CNM_ProductionMetricInterfaces.MeasurementEntryStruct;
	(* mailbox flag for the database that we have a new entry, should be reset by the server when data was read *)
	{ attribute 'TcHmiSymbol.Show' }
	newDataAvailable :BOOL := FALSE;
	(* command delegates *)
	measurementCommands :MeasurementRecorderCommands;
	(* error for failed queryInterface *)
	interfaceQueryFailedAlarm :CNM_ConcreteMessages.TcError(event := Global.TC_EVENTS.MemoryErrors.MeasurementRecorderQueryInterfaceFailed , injectedService := THIS^.messageService);
	(* error for maximum queue size *)
	maxQueueSizeAlarm :CNM_ConcreteMessages.TcError(event := Global.TC_EVENTS.MemoryErrors.MeasurementsMaxQueueSize, injectedService := THIS^.messageService); 
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[]]></ST>
    </Implementation>
    <Method Name="addMeasurementEntry" Id="{6b525bc4-05bf-47e7-ad5f-196f5332a77a}">
      <Declaration><![CDATA[(*
## Short summary

This methods creates a new measurement entry and queues it for the database insection.

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2025 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

*)
METHOD addMeasurementEntry :CNM_ReturnTypes.SingleExecutionResult;
VAR_INPUT
	(* product identifier for that specific part *)
	partIdentifier	:Tc2_System.T_MaxString;
	(* name of the measurement, e.g. label position, cell voltage, oven temperature *)
	name	: Tc2_System.T_MaxString;
	(* unit of the measurement, e.g. mm, V, °C *)
	unit	: CNM_ProductionMetricInterfaces.UnitString;
	(* Permissible value range of the measurement for OK parts*)
	range	: CNM_ProductionMetricInterfaces.MeasurementRangeStruct;
	(* value of the measurement *)
	value	: LREAL;
END_VAR
VAR
	dataset :CNM_ProductionMetricInterfaces.MeasurementEntryStruct;
	dto :POINTER TO MeasurementData := 0;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[addMeasurementEntry := CNM_ReturnTypes.SingleExecutionResult.ABORTED;
// check if we can queue the dataset - throw error if the max queuesize is reached
IF ( THIS^.dataSetList.size >= THIS^.maxQueueSize ) THEN
	THIS^.maxQueueSizeAlarm.throw();
	RETURN;
END_IF

dataset.process := THIS^.configuration.process;
dataset.productType := THIS^.configuration.productType;
dataset.partIdentifier := partIdentifier;
dataset.name := name;
dataset.unit := unit;
dataset.range := range;
dataset.value := value;
dataset.timestamp := GetCurrentLTimeStamp();
dto := __NEW(MeasurementData(data := dataset));
IF (dto <> 0) THEN
	THIS^.dataSetList.append(dto^);
	addMeasurementEntry := CNM_ReturnTypes.SingleExecutionResult.SUCCESS;
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Property Name="className" Id="{e9fafead-7b17-4a6e-a2b6-04833090b322}">
      <Declaration><![CDATA[(*

## Short summary

This abstract property returns the class name of the concrete object, 
which is useful for logging/debugging purpose or to check the class name
for ``__DELETE`` in factories (sometimes it's necessary to do more 
than just to free the memory).

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

*)
PROPERTY className : CNM_AbstractObject.ClassName
]]></Declaration>
      <Get Name="Get" Id="{48e840a2-9747-48e2-870f-026c89326ece}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[className := 'MeasurementRecorder';
]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="commands" Id="{69971e7a-9a7c-4879-87b3-37e1a1a519de}">
      <Declaration><![CDATA[(* 
## Short summary

This is a fluent interface that provides single attempt commands, which can be evaluated by a cycle manager instance.
### Example 
```
	
	// execute command when leaving a step 
	cycleManager.leave(
		measurement.commands.addMeasurementEntry(
			partIdentifier	:= 'Part123',
			name := 'Voltage Check',
			unit := 'V',
			range := productType.VoltageCheck.Range,
			value := 3.14
		)
	); 
```	

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2025 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>
	
*)
PROPERTY commands : CNM_ProductionMetricInterfaces.IMeasurementRecorderCommands
]]></Declaration>
      <Get Name="Get" Id="{1a6e9df0-5c71-4683-b8b4-02d3632a48c3}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[commands := THIS^.measurementCommands;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="configuration" Id="{8c6c9ce8-a72b-4381-837a-dcefffa1baa8}">
      <Declaration><![CDATA[(*
## Short summary

This property returns an fluent interface for the measurement configuration.
The following things should be configured after a type / product change was performed:
 -product type: either the name of the overall product or the individual feed parts to be processed
 
 
The process name can be set once during the initialization of the PLC as it usually doesn't change.

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

*)
PROPERTY configuration : CNM_ProductionMetricInterfaces.IProductionMetricsConfiguration
]]></Declaration>
      <Get Name="Get" Id="{17e34e98-91a5-4287-acfa-52837b64ad94}">
        <Declaration><![CDATA[VAR_INST
	config :DefaultMeasurementConfiguration;
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[configuration := config;
 ]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Method Name="disable" Id="{85580d3e-a0d9-4eae-8a7c-e55f37443f80}">
      <Declaration><![CDATA[(* 
## Short summary

This method disables a node (E.g. axes should be disabled). It can take mutliple cycles. It has to be implemented for every node/device.
The execute input needs a rising edge to execute the method.
If there is nothing to disable, just return a 'SUCCESS' state.

This method is called automatically by the operation mode handler.

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2024 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

*)
METHOD disable : CNM_ReturnTypes.SingleExecutionState
VAR_INPUT
	execute	: BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// nothing to disable
disable := CNM_ReturnTypes.SingleExecutionState.SUCCESS;]]></ST>
      </Implementation>
    </Method>
    <Method Name="enable" Id="{5db0ee99-137a-4868-bf64-08bc017ad0bc}">
      <Declaration><![CDATA[(* 
## Short summary

This method enables a node. It can take mutliple cycles. It has to be implemented for every node/device.
The intention is to enable devices here, e.g. axes, laser, dispenser etc.
The execute input needs a rising edge to execute the method.
If there is nothing to enable, just return a 'SUCCESS' state.

This method is called automatically by the operation mode handler.

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2024 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

*)
METHOD enable : CNM_ReturnTypes.SingleExecutionState
VAR_INPUT
	execute	: BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// nothing to enable
enable := CNM_ReturnTypes.SingleExecutionState.SUCCESS;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="FB_init" Id="{c95289b1-cbf2-444e-8c62-3bf217ce1edd}">
      <Declaration><![CDATA[(*

## Short summary

The constructor ``FB_init`` is needed to create an unique hash code.
The hash code is a pseudo random number create with a [xorshift](https://en.wikipedia.org/wiki/Xorshift) algorithm.
It can be overwritten on derivations, because it will be called implicit, ``SUPER^.FB_init()`` is not required.
For more information check: [Behavoir with derived function blocks](https://infosys.beckhoff.com/content/1033/tc3_plc_intro/5482088715.html?id=6983869892358031022)

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>



*)
METHOD FB_init : BOOL
VAR_INPUT
	(* if TRUE, the retain variables are initialized (warm start / cold start)*)
	bInitRetains	: BOOL;
	(* if TRUE, the instance afterwards gets moved into the copy code (online change) *)
	bInCopyCode	:BOOL;
	(* the node were this node should be appended to *)
	parentNode :CNM_OpModeHandler.INodeInitialization;
END_VAR

]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.hmiInfo.template := 'MeasurementRecorder';
THIS^.isInHome := TRUE;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="initialize" Id="{e505c86a-4c37-4d67-aea4-76e8f0348c84}">
      <Declaration><![CDATA[(* 
## Short summary

This method contains instructions and sequences for the init mode. 
This mode is intended for initializing a machine, e.g. loading product type data from recipes, establish a connection to global production systems (MES).
If the node should do nothing, return a 'SUCCESS'.
It should run until all initializations are done or the mode is stopped immedtiately or a stop request is raised (THIS^.modeControl.stopRequest). 
This method is called automatically by the operation mode handler.

**Attention:** If this method returns the state 'ERROR', the operation mode handler automatically disables the whole machine! 

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2024 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

*)
METHOD initialize : CNM_ReturnTypes.SingleExecutionState
VAR_INPUT
	execute	: BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.measurementCommands.setRecorder(THIS^);
initialize := CNM_ReturnTypes.SingleExecutionState.SUCCESS;
]]></ST>
      </Implementation>
    </Method>
    <Property Name="maxQueueSize" Id="{2b972078-3398-4bd9-a66f-93645afae931}">
      <Declaration><![CDATA[(*
## Short summary

This property getter returns the maximum queue size for the data recorder. 
If the dataset list has reached this size, no other dataset will be stored and an alarm will be raised.
For this class the maximum queue size can be configured as library parameter ''QUEUE_SIZE_FOR_DATA_RECORDS_PER_RECORDER''.
Overwrite this property for extended classes as the default implementation accesses the Parameter List of the CNM_ProductionMetrics library! 

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

*)

PROPERTY PROTECTED maxQueueSize : UDINT
]]></Declaration>
      <Get Name="Get" Id="{b2a3798d-4648-4fe9-b73d-486e6c83915f}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[maxQueueSize := Settings.QUEUE_SIZE_FOR_DATA_RECORDS_PER_RECORDER;

]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Method Name="run" Id="{51dfdb14-2278-46ec-b91d-3462cb1ddf3b}">
      <Declaration><![CDATA[(* 
## Short summary

This method will be called in every cycle for a node. It can be used to implement hardware drivers/measurements/monitoring.
The returned state defines the overall state of the node. It should return BUSY when the node executes a command, otherwise SUCCESS( or IDLE if there is nothing to do). 
(Simple monitoring is not a command an should return SUCCESS).  


**Attention:** the returned SingleExecutionState will be evaluated cyclically wihtin the node tree. 
In case a node returns an ERROR state, the whole machine will be disabled. 
Return ERROR only for fatal or critical errors and handle other errors within the node.
 

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2025 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>
	
*)
METHOD run : CNM_ReturnTypes.SingleExecutionState
VAR_INST
	cycleManager :CNM_CycleManager.SimpleCycleManager;
END_VAR
VAR CONSTANT
	WAIT_FOR_DATA :DINT := 10;
	SET_DATA :DINT := 11;
	DATA_ERROR :DINT:= 12;
	WAIT_DATA_RECEIVED :DINT := 13;
END_VAR
VAR
	data :CNM_ProductionMetricInterfaces.IMeasurementData;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[cycleManager(execute := TRUE);

CASE cycleManager.step.current OF
CNM_ReturnTypes.DefaultSteps.STEP.INIT:
	run := CNM_ReturnTypes.SingleExecutionState.SUCCESS;
	cycleManager.proceedWith(WAIT_FOR_DATA);
WAIT_FOR_DATA:
	run := CNM_ReturnTypes.SingleExecutionState.SUCCESS;
	IF (THIS^.dataSetList.size > 0) THEN
		run := CNM_ReturnTypes.SingleExecutionState.BUSY;
		cycleManager.proceedWith(SET_DATA); 
	END_IF
SET_DATA:
	run := CNM_ReturnTypes.SingleExecutionState.BUSY;
	IF (__QUERYINTERFACE(THIS^.dataSetList.dequeue(), data)) THEN
		(* fill dataslot *)
		THIS^.measurement := data.dataset;
		(* delete DTO *)
		data.destruct();
		(* set mailbox flag *)
		THIS^.newDataAvailable := TRUE;
		cycleManager.proceedWith(WAIT_DATA_RECEIVED);
	ELSE
		cycleManager.proceedWith(DATA_ERROR);
	END_IF
DATA_ERROR:
	cycleManager.step.next := SET_DATA;
	cycleManager.handle(THIS^.interfaceQueryFailedAlarm);
WAIT_DATA_RECEIVED:
	run := CNM_ReturnTypes.SingleExecutionState.BUSY;
	IF (NOT THIS^.newDataAvailable) THEN
		// clear data slot
		Tc2_System.MEMSET(destAddr := ADR(THIS^.measurement), 0, SIZEOF(THIS^.measurement));
		run := CNM_ReturnTypes.SingleExecutionState.SUCCESS;
		cycleManager.proceedWith(WAIT_FOR_DATA);
	END_IF
END_CASE
]]></ST>
      </Implementation>
    </Method>
    <Method Name="stopImmediate" Id="{eabcc1db-adc7-4b6a-8c7f-99b505a01c91}">
      <Declaration><![CDATA[(* 
## Short summary

This method executes stops all movements of a node. It has to be overwritten for every node. 
E.g. axes should perform a quickstop, cylinders should be turned off, etc.
If the node should do nothing, return a 'SUCCESS'.
It should stop axes/cylinders/process (e.g. laser welding, dispensing) endless until the manual mode is stopped via stop request or immediate stop.
This method is called automatically by the operation mode handler before disabling the machine or if the operator selects an immediate stop.

**Attention:** If this method returns the state 'ERROR', the operation mode handler automatically disables the whole machine! 

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2024 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

*)
METHOD stopImmediate : CNM_ReturnTypes.SingleExecutionState
VAR_INPUT
	execute	: BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// nothing to stop
stopImmediate := CNM_ReturnTypes.SingleExecutionState.SUCCESS;
]]></ST>
      </Implementation>
    </Method>
  </POU>
</TcPlcObject>