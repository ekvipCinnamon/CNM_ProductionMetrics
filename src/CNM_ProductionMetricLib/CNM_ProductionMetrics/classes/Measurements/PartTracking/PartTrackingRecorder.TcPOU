<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1">
  <POU Name="PartTrackingRecorder" Id="{417ecab2-13e3-4f41-aa54-1583a57a92cd}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK PartTrackingRecorder EXTENDS CNM_OpModeHandler.AbstractCyclicNode IMPLEMENTS CNM_ProductionMetricInterfaces.IPartTracker
VAR
	currentData :CNM_ProductionMetricInterfaces.PartDataTrackingStruct;
	(* queue for the measurements *)
	dataSetList :CNM_Collections.LinkedList;
	(* the variable that is used to provide data for the database *)
	{ attribute 'TcHmiSymbol.ShowRecursively' }
	partDataSet :CNM_ProductionMetricInterfaces.PartDataTrackingStruct;
	(* mailbox flag for the database that we have a new entry, should be reset by the server when data was read *)
	{ attribute 'TcHmiSymbol.Show' }
	newDataAvailable :BOOL := FALSE;
	(* command delegates *)
	partTrackerCommands :PartTrackingCommands;
	(* error for failed queryInterface *)
	interfaceQueryFailedAlarm :CNM_ConcreteMessages.TcError(event := Global.TC_EVENTS.MemoryErrors.PartTrackerQueryInterfacFailed , injectedService := THIS^.messageService);
	(* error for maximum queue size *)
	maxQueueSizeAlarm :CNM_ConcreteMessages.TcError(event := Global.TC_EVENTS.MemoryErrors.PartTrackingMaxQueueSize, injectedService := THIS^.messageService); 
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[]]></ST>
    </Implementation>
    <Property Name="className" Id="{50533924-911e-49a0-9d67-1fdd52142c31}">
      <Declaration><![CDATA[(*

## Short summary

This abstract property returns the class name of the concrete object, 
which is useful for logging/debugging purpose or to check the class name
for ``__DELETE`` in factories (sometimes it's necessary to do more 
than just to free the memory).

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

*)
PROPERTY className : CNM_AbstractObject.ClassName
]]></Declaration>
      <Get Name="Get" Id="{13289ea0-c6ac-494b-8af7-219c7f0970ef}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[className := 'PartTrackingRecorder';
]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="commands" Id="{cf9e4e74-bcc1-4476-bcf5-c8b899411ca9}">
      <Declaration><![CDATA[(* 
## Short summary

This property is a fluent interface that provides single attempt commands, which can be evaluated by a cycle manager instance.
### Example 
```
	
	// execute command when leaving a step 
	cycleManager.leave(
		partTracker.commands.partProcessingDone(
			partIdentifier := 'Part123',
			nokReason := 0,
			additionalMessage := 'SPC Part'
		)
	);  
```	

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2025 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>
	
*)

PROPERTY commands : CNM_ProductionMetricInterfaces.IPartTrackingRecorderCommands
]]></Declaration>
      <Get Name="Get" Id="{4c6364e1-a3c6-49f7-be82-93084c469ddb}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[commands := THIS^.partTrackerCommands;
]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="configuration" Id="{67c8b66f-0dc7-4820-843f-4f527f12e44b}">
      <Declaration><![CDATA[(*

## Short summary

This property returns an fluent interface for part counter configuration.
The following things should be configured after a type / product / batch change was performed:
 -batch: insert the current/new batch name/number as string
 -product type: either the name of the overall product or the individual feed parts to be processed

The process name can be set once during the initialization of the PLC as it usually doesn't change.

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2025 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

*)
PROPERTY configuration : CNM_ProductionMetricInterfaces.IPartTrackerConfiguration
]]></Declaration>
      <Get Name="Get" Id="{b3d64a8c-be4a-47c3-97c5-cae744d3a341}">
        <Declaration><![CDATA[VAR_INST
	config :PartTrackingConfiguration;
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[configuration := config;
]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Method Name="disable" Id="{aad49f93-5518-4a68-944a-ee62404ec215}">
      <Declaration><![CDATA[(* 
## Short summary

This method disables a node (E.g. axes should be disabled). It can take mutliple cycles. It has to be implemented for every node/device.
The execute input needs a rising edge to execute the method.
If there is nothing to disable, just return a 'SUCCESS' state.

This method is called automatically by the operation mode handler.

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2024 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

*)
METHOD disable : CNM_ReturnTypes.SingleExecutionState
VAR_INPUT
	execute	: BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// nothing to disable
disable := CNM_ReturnTypes.SingleExecutionState.SUCCESS;]]></ST>
      </Implementation>
    </Method>
    <Method Name="enable" Id="{4fc9ce0c-d6ff-4bf7-8132-f6c8a6d82bc7}">
      <Declaration><![CDATA[(* 
## Short summary

This method enables a node. It can take mutliple cycles. It has to be implemented for every node/device.
The intention is to enable devices here, e.g. axes, laser, dispenser etc.
The execute input needs a rising edge to execute the method.
If there is nothing to enable, just return a 'SUCCESS' state.

This method is called automatically by the operation mode handler.

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2024 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

*)
METHOD enable : CNM_ReturnTypes.SingleExecutionState
VAR_INPUT
	execute	: BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// nothing to enable
enable := CNM_ReturnTypes.SingleExecutionState.SUCCESS;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="FB_init" Id="{b7d4791e-04ed-4a62-b3ff-c16b799073bf}">
      <Declaration><![CDATA[(*

## Short summary

The constructor ``FB_init`` is needed to create an unique hash code.
The hash code is a pseudo random number create with a [xorshift](https://en.wikipedia.org/wiki/Xorshift) algorithm.
It can be overwritten on derivations, because it will be called implicit, ``SUPER^.FB_init()`` is not required.
For more information check: [Behavoir with derived function blocks](https://infosys.beckhoff.com/content/1033/tc3_plc_intro/5482088715.html?id=6983869892358031022)

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>



*)
METHOD FB_init : BOOL
VAR_INPUT
	(* if TRUE, the retain variables are initialized (warm start / cold start)*)
	bInitRetains	: BOOL;
	(* if TRUE, the instance afterwards gets moved into the copy code (online change) *)
	bInCopyCode	:BOOL;
	(* the node were this node should be appended to *)
	parentNode :CNM_OpModeHandler.INodeInitialization;
END_VAR

]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.hmiInfo.template := 'PartTrackingRecorder';
THIS^.isInHome := TRUE;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="initialize" Id="{18020f95-fd8f-4adf-a8ad-c1b0faa52467}">
      <Declaration><![CDATA[(* 
## Short summary

This method contains instructions and sequences for the init mode. 
This mode is intended for initializing a machine, e.g. loading product type data from recipes, establish a connection to global production systems (MES).
If the node should do nothing, return a 'SUCCESS'.
It should run until all initializations are done or the mode is stopped immedtiately or a stop request is raised (THIS^.modeControl.stopRequest). 
This method is called automatically by the operation mode handler.

**Attention:** If this method returns the state 'ERROR', the operation mode handler automatically disables the whole machine! 

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2024 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

*)
METHOD initialize : CNM_ReturnTypes.SingleExecutionState
VAR_INPUT
	execute	: BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.partTrackerCommands.setRecorder(THIS^);
initialize := CNM_ReturnTypes.SingleExecutionState.SUCCESS;
]]></ST>
      </Implementation>
    </Method>
    <Property Name="maxQueueSize" Id="{ddc869e8-c5d9-4531-bb44-3a55e467464c}">
      <Declaration><![CDATA[(*
## Short summary

This property getter returns the maximum queue size for the data recorder. 
If the dataset list has reached this size, no other dataset will be stored and an alarm will be raised.
For this class the maximum queue size can be configured as library parameter ''QUEUE_SIZE_FOR_DATA_RECORDS_PER_RECORDER''.
Overwrite this property for extended classes as the default implementation accesses the Parameter List of the CNM_ProductionMetrics library! 

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

*)

PROPERTY PROTECTED maxQueueSize : UDINT
]]></Declaration>
      <Get Name="Get" Id="{4572b5e3-63e7-46f2-8c58-2c8976c27a4d}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[maxQueueSize := Settings.QUEUE_SIZE_FOR_DATA_RECORDS_PER_RECORDER;

]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Method Name="run" Id="{15f55e9f-d3fb-4420-80da-0eb159b6e532}">
      <Declaration><![CDATA[(* 
## Short summary

This method will be called in every cycle for a node. It can be used to implement hardware drivers/measurements/monitoring.
The returned state defines the overall state of the node. It should return BUSY when the node executes a command, otherwise SUCCESS( or IDLE if there is nothing to do). 
(Simple monitoring is not a command an should return SUCCESS).  


**Attention:** the returned SingleExecutionState will be evaluated cyclically wihtin the node tree. 
In case a node returns an ERROR state, the whole machine will be disabled. 
Return ERROR only for fatal or critical errors and handle other errors within the node.
 

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2025 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>
	
*)
METHOD run : CNM_ReturnTypes.SingleExecutionState
VAR_INST
	cycleManager :CNM_CycleManager.SimpleCycleManager;
END_VAR
VAR CONSTANT
	WAIT_FOR_DATA :DINT := 10;
	SET_DATA :DINT := 11;
	DATA_ERROR :DINT := 12;
	WAIT_DATA_RECEIVED :DINT := 13;
END_VAR
VAR
	data :CNM_ProductionMetricInterfaces.IPartTrackingData;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[cycleManager(execute := TRUE);

CASE cycleManager.step.current OF
CNM_ReturnTypes.DefaultSteps.STEP.INIT:
	run := CNM_ReturnTypes.SingleExecutionState.SUCCESS;
	cycleManager.proceedWith(WAIT_FOR_DATA);
WAIT_FOR_DATA:
	run := CNM_ReturnTypes.SingleExecutionState.SUCCESS;
	IF (THIS^.dataSetList.size > 0) THEN
		run := CNM_ReturnTypes.SingleExecutionState.BUSY;
		cycleManager.proceedWith(SET_DATA); 
	END_IF
SET_DATA:
	run := CNM_ReturnTypes.SingleExecutionState.BUSY;
	IF (__QUERYINTERFACE(THIS^.dataSetList.dequeue(), data)) THEN
		(* fill dataslot *)
		THIS^.partDataSet := data.dataset;
		(* delete DTO *)
		data.destruct();
		(* set mailbox flag *)
		THIS^.newDataAvailable := TRUE;
		cycleManager.proceedWith(WAIT_DATA_RECEIVED);
	ELSE
		cycleManager.proceedWith(DATA_ERROR);
	END_IF
DATA_ERROR:
	cycleManager.step.next := SET_DATA;
	cycleManager.handle(THIS^.interfaceQueryFailedAlarm);
WAIT_DATA_RECEIVED:
	run := CNM_ReturnTypes.SingleExecutionState.BUSY;
	IF (NOT THIS^.newDataAvailable) THEN
		// clear data slot
		Tc2_System.MEMSET(destAddr := ADR(THIS^.partDataSet), 0, SIZEOF(THIS^.partDataSet));
		run := CNM_ReturnTypes.SingleExecutionState.SUCCESS;
		cycleManager.proceedWith(WAIT_FOR_DATA);
	END_IF
END_CASE
]]></ST>
      </Implementation>
    </Method>
    <Method Name="setPartProcessingDone" Id="{59b7b84b-0948-432b-968b-a63aadd5fda5}">
      <Declaration><![CDATA[(*

## Short summary

This method creates a part counter dataset for the currenttly processed part.
The part will be counted as OK part if the nokReason is set to 0 and not OK otherwise.
The additionalMessage can be used to provide additional information, e.g. SPC part or measurements that are out of the permissible range. 

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2025 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

*)
METHOD setPartProcessingDone : CNM_ProductionMetricInterfaces.CNM_ReturnTypes.SingleExecutionResult
VAR_INPUT
	(* the part number as string *)
	partIdentifier	: Tc2_System.T_MaxString;
	(* if not 0, the record will be marked as not OK part *)
	nokReason	: DWORD;
	(* can be used to provide additional informations for the record, e.g. voltage too low *)
	additionalMessage	: Tc2_System.T_MaxString;
END_VAR
VAR
	dto :POINTER TO PartTrackingData;
	backupEndTimestamp :LDT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[setPartProcessingDone := CNM_ReturnTypes.SingleExecutionResult.ABORTED;
// check if we can queue the dataset - throw error if the max queuesize is reached
IF ( THIS^.dataSetList.size >= THIS^.maxQueueSize ) THEN
	THIS^.maxQueueSizeAlarm.throw();
	RETURN;
END_IF

backupEndTimestamp  := THIS^.currentData.endTimestamp;

THIS^.currentData.partIdentifier := partIdentifier;
THIS^.currentData.cycleTime := 
	SEL(
		TO_UDINT(THIS^.currentData.endTimestamp) > 0, 
		TO_LTIME(0), 
		TO_LTIME(GetCurrentLTimeStamp() - THIS^.currentData.endTimestamp )
	);
THIS^.currentData.endTimestamp := GetCurrentLTimeStamp();
THIS^.currentData.processingTime := 
	SEL(
		TO_UDINT(THIS^.currentData.startTimestamp) > 0, 
		TO_LTIME(0), 
		TO_LTIME(THIS^.currentData.endTimestamp - THIS^.currentData.startTimestamp));
THIS^.currentData.process := THIS^.configuration.process;
THIS^.currentData.productType := THIS^.configuration.productType;
THIS^.currentData.targetCycletime := THIS^.configuration.targetCycleTime;
THIS^.currentData.additionalMessage := additionalMessage;
THIS^.currentData.nokReason := nokReason;
THIS^.currentData.order := THIS^.configuration.order;
dto := __NEW(PartTrackingData(data := THIS^.currentData));
IF (dto <> 0) THEN
	setPartProcessingDone := THIS^.dataSetList.append(dto^);
ELSE
	// restore data for retry
	THIS^.currentData.endTimestamp := backupEndTimestamp;
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="setPartProcessingStarted" Id="{db916b7d-c0a5-44c3-932a-a41e3cfedd77}">
      <Declaration><![CDATA[(*

## Short summary

This method starts a new process cycle and sets the start time stamp for the corresponding partIdentifier.

**Attention:** calling this method clears the currently set part data, e.g. if the last process cycle couldn't be finished.

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2025 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

*)
METHOD setPartProcessingStarted : CNM_ProductionMetricInterfaces.CNM_ReturnTypes.SingleExecutionResult
VAR_INPUT
	(* the part number as string *)
	partIdentifier	: Tc2_System.T_MaxString;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.currentData.partIdentifier := partIdentifier;
THIS^.currentData.startTimestamp := GetCurrentLTimeStamp();
setPartProcessingStarted := CNM_ReturnTypes.SingleExecutionResult.SUCCESS;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="stopImmediate" Id="{49781e7d-7d67-4494-a2ca-d2e521043652}">
      <Declaration><![CDATA[(* 
## Short summary

This method executes stops all movements of a node. It has to be overwritten for every node. 
E.g. axes should perform a quickstop, cylinders should be turned off, etc.
If the node should do nothing, return a 'SUCCESS'.
It should stop axes/cylinders/process (e.g. laser welding, dispensing) endless until the manual mode is stopped via stop request or immediate stop.
This method is called automatically by the operation mode handler before disabling the machine or if the operator selects an immediate stop.

**Attention:** If this method returns the state 'ERROR', the operation mode handler automatically disables the whole machine! 

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2024 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

*)
METHOD stopImmediate : CNM_ReturnTypes.SingleExecutionState
VAR_INPUT
	execute	: BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// nothing to stop
stopImmediate := CNM_ReturnTypes.SingleExecutionState.SUCCESS;
]]></ST>
      </Implementation>
    </Method>
  </POU>
</TcPlcObject>